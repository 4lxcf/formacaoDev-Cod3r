"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomThought = exports.getAssociated = exports.rankingAuthors = exports.bioAuthor = exports.aboutAuthor = exports.search = void 0;
var scraping_1 = require("./modules/scraping");
var pensador_1 = require("./modules/pensador/");
var utils_1 = require("./utils");
/**
 *
 * @param {{query,limit}} data
 * @param {string} data.query - o termo que queira buscar (obrigatório)
 * @param {number} data.limit - a quantidade que deseja (padrão=1)
 * @description Caso queira buscar uma lista de pensamento usando algum termo específico
 * @example
 *
 *const {err,success} = await search({query:"elon musk"})
 *	//err - em caso de erro
 *	//success - em caso de sucesso ira retorna o pensamento
 * const {author, thought, query,total } = success
 */
function search(_a) {
    var _b = _a.limit, limit = _b === void 0 ? 1 : _b, query = _a.query;
    return __awaiter(this, void 0, void 0, function () {
        var _c, err, html, _d, thought, total, author;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0: return [4 /*yield*/, (0, pensador_1.search)(query)];
                case 1:
                    _c = _e.sent(), err = _c.err, html = _c.html;
                    if (err) {
                        return [2 /*return*/, { error: err }];
                    }
                    if (!html) {
                        return [2 /*return*/, { error: "html vázio" }];
                    }
                    _d = (0, scraping_1.searchScrap)(html, limit), thought = _d.thought, total = _d.total;
                    author = (0, scraping_1.authorScrap)(html);
                    return [2 /*return*/, {
                            success: {
                                author: author,
                                thought: thought,
                                query: query,
                                total: total,
                            },
                        }];
            }
        });
    });
}
exports.search = search;
/**
 *
 * @param {{query}} data
 * @param {string} data.query - o termo que queira buscar (obrigatório)
 * @description Diferente do `bio-author` que retorna a biografia completa, aqui ira retorna um breve resumo do autor.
 * @example
 *
 *const {err,success} = await aboutAuthor({query:"elon musk"})
 *	//err - em caso de erro
 *	//success - em caso de sucesso
 * const {name, thought_total,avatar_url, info,associated,bio,tags} = success
 */
function aboutAuthor(_a) {
    var query = _a.query;
    return __awaiter(this, void 0, void 0, function () {
        var _b, err, html, result;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, (0, pensador_1.getAuthor)(query)];
                case 1:
                    _b = _c.sent(), err = _b.err, html = _b.html;
                    if (err) {
                        return [2 /*return*/, { error: err }];
                    }
                    if (!html) {
                        return [2 /*return*/, { error: "html vazio" }];
                    }
                    result = (0, scraping_1.authorScrap)(html);
                    if (!result.info) {
                        return [2 /*return*/, { error: "".concat(query, " n\u00E3o \u00E9 um autor.") }];
                    }
                    return [2 /*return*/, {
                            success: result,
                        }];
            }
        });
    });
}
exports.aboutAuthor = aboutAuthor;
/**
 *
 * @param {{query}} data
 * @param {string} data.query - o termo que queira buscar (obrigatório)
 * @description Utilizado para obter a biografia de um autor, recebe o conteúdo da pagina dividos por tópicos.
 * @example
 *
 *const {err,success} = await bioAuthor({query:"o rappa"})
 *	//err - em caso de erro
 *	//success - em caso de sucesso
 * const {associated, content,name, info,associated,title} = success
 */
function bioAuthor(_a) {
    var query = _a.query;
    return __awaiter(this, void 0, void 0, function () {
        var _b, err, html, result;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, (0, pensador_1.getBio)(query)];
                case 1:
                    _b = _c.sent(), err = _b.err, html = _b.html;
                    if (err) {
                        return [2 /*return*/, { error: err }];
                    }
                    if (!html) {
                        return [2 /*return*/, { error: "html vazio" }];
                    }
                    result = (0, scraping_1.bioAuthorsScrap)(html);
                    return [2 /*return*/, {
                            success: result,
                        }];
            }
        });
    });
}
exports.bioAuthor = bioAuthor;
/**
 * @description Ira buscar na home do site os 9 autores mais populares.
 * @example
 *
 *const {err,success} = await rankingAuthor()
 *	//err - em caso de erro
 *	//success - em caso de sucesso
 * const {avatar_url,href,name,position} = success[0] //retorna um array
 */
function rankingAuthors() {
    return __awaiter(this, void 0, void 0, function () {
        var _a, err, html, result;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, (0, pensador_1.getHome)()];
                case 1:
                    _a = _b.sent(), err = _a.err, html = _a.html;
                    if (err) {
                        return [2 /*return*/, { error: err }];
                    }
                    if (!html) {
                        return [2 /*return*/, { error: "html vazio" }];
                    }
                    result = (0, scraping_1.rakingAuthorsScrap)(html);
                    return [2 /*return*/, {
                            success: result,
                        }];
            }
        });
    });
}
exports.rankingAuthors = rankingAuthors;
/**
 * @param {{query}} data
 * @param {String} data.query - o termo que queira buscar (obrigatório)
 * @description Ao buscar um determinado termo, ira obter uma lista de temas associados ao termo.
 * @example
 *
 *const {err,success} = await rankingAuthor()
 *	//err - em caso de erro
 *	//success - em caso de sucesso
 * const {href,name,category} = success[0] //retorna um array
 */
function getAssociated(_a) {
    var query = _a.query;
    return __awaiter(this, void 0, void 0, function () {
        var _b, err, html, result;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, (0, pensador_1.search)(query)];
                case 1:
                    _b = _c.sent(), err = _b.err, html = _b.html;
                    if (err) {
                        return [2 /*return*/, { error: err }];
                    }
                    if (!html) {
                        return [2 /*return*/, { error: "html vazio" }];
                    }
                    result = (0, scraping_1.topicsScrap)(html);
                    if (result.length == 0) {
                        return [2 /*return*/, { error: "Não foi encontrado nenhum resultado" }];
                    }
                    return [2 /*return*/, {
                            success: result,
                        }];
            }
        });
    });
}
exports.getAssociated = getAssociated;
/**
 * @param {String} topic o tópico que queira buscar (obrigatório)
 * @description Caso queira um pensamento aleatório sobre algum tópico especifico ou não.
 * @example
 *
 *const {err,success} = await randomThought()
 *	//err - em caso de erro
 *	//success - em caso de sucesso
 * const {author, content, image_url, url} = success
 */
function randomThought(topic) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, err, html, error, result, listThoughts, _b, thought, total, topicSearch, thoughts, errorThoughts, _c, thought, total;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0: return [4 /*yield*/, (0, pensador_1.search)(topic ? topic : "frases")];
                case 1:
                    _a = _d.sent(), err = _a.err, html = _a.html;
                    error = ErrorPensador({ err: err, html: html });
                    if (error) {
                        return [2 /*return*/, { error: error }];
                    }
                    result = (0, scraping_1.topicsScrap)(html);
                    listThoughts = [];
                    if (!(result.length == 0)) return [3 /*break*/, 2];
                    _b = (0, scraping_1.searchScrap)(html, 99), thought = _b.thought, total = _b.total;
                    if (total == 0) {
                        return [2 /*return*/, { error: "não encontrei nenhum resultado" }];
                    }
                    listThoughts = thought;
                    return [3 /*break*/, 4];
                case 2:
                    topicSearch = result[(0, utils_1.randomNumber)(result.length)];
                    return [4 /*yield*/, (0, pensador_1.getHref)(topicSearch.href)];
                case 3:
                    thoughts = _d.sent();
                    errorThoughts = ErrorPensador(thoughts);
                    if (errorThoughts) {
                        return [2 /*return*/, { error: errorThoughts }];
                    }
                    _c = (0, scraping_1.searchScrap)(thoughts.html, 99), thought = _c.thought, total = _c.total;
                    if (total == 0) {
                        return [2 /*return*/, { error: "não encontrei nenhum resultado" }];
                    }
                    listThoughts = thought;
                    _d.label = 4;
                case 4: return [2 /*return*/, {
                        success: listThoughts[(0, utils_1.randomNumber)(listThoughts.length)],
                    }];
            }
        });
    });
}
exports.randomThought = randomThought;
function ErrorPensador(data) {
    if (data.err) {
        return data.err;
    }
    if (!data.html) {
        return "html vazio";
    }
}
